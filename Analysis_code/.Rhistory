baselines = ebp_baselines3,
n_mcsim = 5000)
zf_cluster.1 <- top_clusters(zf_result, zones, k = 10, overlapping = FALSE)
zf_cluster.1
mod2 <- glm.nb(round(total) ~  offset(log(forest))  + distance + I(distance^2) + I(distance^3) + season + time_num,
data = used_data %>% filter(time < 202209), init.theta = 0.02)
summary(mod2)
ebp_baselines2 <- used_data %>%
filter(time >= 202209 & time <= 202212) %>%
mutate(mu = predict(mod2, newdata = ., type = 'response')) %>%
scanstatistics::df_to_matrix(time_col = 'SIG_CD',
location_col = 'time',
value_col = 'mu') %>% t()
nb_result <- scan_eb_negbin(counts = counts,
zones = zones,
baselines = ebp_baselines2,
n_mcsim = 5000)
nb_cluster.1 <- top_clusters(nb_result, zones, k = 10)
nb_cluster.1
mod2 <- glm.nb(round(total) ~  offset(log(forest))  + distance + I(distance^2) + season + time_num,
data = used_data %>% filter(time < 202209), init.theta = 0.02)
summary(mod2)
ebp_baselines2 <- used_data %>%
filter(time >= 202209 & time <= 202212) %>%
mutate(mu = predict(mod2, newdata = ., type = 'response')) %>%
scanstatistics::df_to_matrix(time_col = 'SIG_CD',
location_col = 'time',
value_col = 'mu') %>% t()
nb_result <- scan_eb_negbin(counts = counts,
zones = zones,
baselines = ebp_baselines2,
n_mcsim = 5000)
nb_cluster.1 <- top_clusters(nb_result, zones, k = 10)
nb_cluster.1
used_data$time_num
mod2 <- glm.nb(round(total) ~  offset(log(forest))  + distance + I(distance^2) + season + time_num,
data = used_data %>% filter(time < 202209), init.theta = 0.02)
summary(mod2)
ebp_baselines2 <- used_data %>%
filter(time >= 202209 & time <= 202212) %>%
mutate(mu = predict(mod2, newdata = ., type = 'response')) %>%
scanstatistics::df_to_matrix(time_col = 'SIG_CD',
location_col = 'time',
value_col = 'mu') %>% t()
nb_result <- scan_eb_negbin(counts = counts,
zones = zones,
baselines = ebp_baselines2,
n_mcsim = 5000)
nb_cluster.1 <- top_clusters(nb_result, zones, k = 10)
nb_cluster.1
mod2 <- glm.nb(round(total) ~  offset(log(forest))  + distance + I(distance^2) + I(distance)^3 + season + time_num,
data = used_data %>% filter(time < 202209), init.theta = 0.02)
summary(mod2)
mod2 <- glm.nb(round(total) ~  offset(log(forest))  + distance + I(distance^2) + I(distance^3) + season + time_num,
data = used_data %>% filter(time < 202209), init.theta = 0.02)
summary(mod2)
ebp_baselines2 <- used_data %>%
filter(time >= 202209 & time <= 202212) %>%
mutate(mu = predict(mod2, newdata = ., type = 'response')) %>%
scanstatistics::df_to_matrix(time_col = 'SIG_CD',
location_col = 'time',
value_col = 'mu') %>% t()
nb_result <- scan_eb_negbin(counts = counts,
zones = zones,
baselines = ebp_baselines2,
n_mcsim = 5000)
nb_cluster.1 <- top_clusters(nb_result, zones, k = 10)
nb_cluster.1
mod3 <- zeroinfl(round(total) ~ offset(log(forest)) + 1  + distance + I(distance^2) + I(distance^3) + season + time_num,
data = used_data %>% filter(time < 202209))
summary(mod3)
ebp_baselines3 <- used_data %>%
filter(time >= 202209 & time <= 202212) %>%
mutate(mu = predict(mod3, newdata = ., type = 'response')) %>%
scanstatistics::df_to_matrix(time_col = 'SIG_CD',
location_col = 'time',
value_col = 'mu') %>% t()
zf_result <- scan_eb_zip(counts = counts,
zones = zones,
baselines = ebp_baselines3,
n_mcsim = 5000)
zf_cluster.1 <- top_clusters(zf_result, zones, k = 10, overlapping = FALSE)
zf_cluster.1
help(zeroinfl)
mod3 <- zeroinfl(round(total) ~ offset(log(forest)) + 1  + distance + I(distance^2) + I(distance^3) + season + time_num,
data = used_data %>% filter(time < 202209),
dist = 'poisson',
link = 'log')
mod2 <- glm.nb(round(total) ~  offset(log(forest))  + distance + I(distance^2) + I(distance^3) + season + time_num,
data = used_data %>% filter(time < 202209), init.theta = 0.02, link = 'log')
summary(mod2)
ebp_baselines2 <- used_data %>%
filter(time >= 202209 & time <= 202212) %>%
mutate(mu = predict(mod2, newdata = ., type = 'response')) %>%
scanstatistics::df_to_matrix(time_col = 'SIG_CD',
location_col = 'time',
value_col = 'mu') %>% t()
nb_result <- scan_eb_negbin(counts = counts,
zones = zones,
baselines = ebp_baselines2,
n_mcsim = 5000)
nb_cluster.1 <- top_clusters(nb_result, zones, k = 10)
nb_cluster.1
starts_val <- list(
count = coef(mod),
zero = rep(0, length(coef(mod)))
)
mod3 <- zeroinfl(round(total) ~ offset(log(forest)) + 1  + distance + I(distance^2) + I(distance^3) + season + time_num,
data = used_data %>% filter(time < 202209),
dist = 'poisson',
link = 'log',
start = starts_val)
starts_val
used_data$distance2 <- used_data$distance^2
used_data$distance3 <- used_data$distance^3
## Poisson
mod = glm(round(total) ~ offset(log(forest)) + 1  + distance + distance2 + distance3 + season ,
data = used_data %>% filter(time < 202209),
family = poisson(link = 'log'))
summary(mod)
ebp_baselines <- used_data %>%
filter(time >= 202209 & time <= 202212) %>%
mutate(mu = predict(mod, newdata = ., type = 'response')) %>%
scanstatistics::df_to_matrix(time_col = 'SIG_CD',
location_col = 'time',
value_col = 'mu') %>% t()
MC.count <- 999
poisson_result <- scan_eb_poisson(counts = counts,
zones = zones,
baselines = ebp_baselines,
n_mcsim = MC.count)
ps_cluster.1 <- top_clusters(poisson_result, zones, k = 10, overlapping = FALSE)
ps_cluster.1
# NB model
library(MASS)
mod2 <- glm.nb(round(total) ~  offset(log(forest))  + distance + distance2 + distance3 + season + time_num,
data = used_data %>% filter(time < 202209), init.theta = 1, link = 'log')
summary(mod2)
ebp_baselines2 <- used_data %>%
filter(time >= 202209 & time <= 202212) %>%
mutate(mu = predict(mod2, newdata = ., type = 'response')) %>%
scanstatistics::df_to_matrix(time_col = 'SIG_CD',
location_col = 'time',
value_col = 'mu') %>% t()
nb_result <- scan_eb_negbin(counts = counts,
zones = zones,
baselines = ebp_baselines2,
n_mcsim = 5000)
nb_cluster.1 <- top_clusters(nb_result, zones, k = 10)
nb_cluster.1
starts_val <- list(
count = coef(mod),
zero = rep(0, length(coef(mod)))
)
mod3 <- zeroinfl(round(total) ~ offset(log(forest)) + 1  + distance + I(distance^2) + I(distance^3) + season + time_num,
data = used_data %>% filter(time < 202209),
dist = 'poisson',
link = 'log',
start = starts_val)
mod3 <- zeroinfl(round(total) ~ offset(log(forest)) + 1  + distance + I(distance^2) + I(distance^3) + season + time_num,
data = used_data %>% filter(time < 202209),
dist = 'poisson',
link = 'log')
starts_val
starts_val <- list(
count = coef(mod),
zero = rep(0, length(coef(mod)))
)
starts_val
## Poisson
mod = glm(round(total) ~ offset(log(forest)) + 1  + distance + distance2 + distance3 + season + time_num,
data = used_data %>% filter(time < 202209),
family = poisson(link = 'log'))
summary(mod)
ebp_baselines <- used_data %>%
filter(time >= 202209 & time <= 202212) %>%
mutate(mu = predict(mod, newdata = ., type = 'response')) %>%
scanstatistics::df_to_matrix(time_col = 'SIG_CD',
location_col = 'time',
value_col = 'mu') %>% t()
MC.count <- 999
poisson_result <- scan_eb_poisson(counts = counts,
zones = zones,
baselines = ebp_baselines,
n_mcsim = MC.count)
ps_cluster.1 <- top_clusters(poisson_result, zones, k = 10, overlapping = FALSE)
ps_cluster.1
starts_val <- list(
count = coef(mod),
zero = rep(0, length(coef(mod)))
)
starts_val
mod3 <- zeroinfl(round(total) ~ offset(log(forest)) + 1  + distance + I(distance^2) + I(distance^3) + season + time_num,
data = used_data %>% filter(time < 202209),
dist = 'poisson',
link = 'log',
start = starts_val)
mod3 <- zeroinfl(round(total) ~ offset(log(forest)) + distance + I(distance^2) + I(distance^3) + season + time_num,
data = used_data %>% filter(time < 202209),
dist = 'poisson',
link = 'log',
start = starts_val)
starts_val <- list(
count = coef(mod),
zero = rep(0.1, length(coef(mod)))
)
mod3 <- zeroinfl(round(total) ~ offset(log(forest)) + distance + I(distance^2) + I(distance^3) + season + time_num,
data = used_data %>% filter(time < 202209),
dist = 'poisson',
link = 'log',
start = starts_val)
## Poisson
mod = glm(round(total) ~ offset(log(forest)) + 1  + distance + distance2 + distance3 + season + time_num,
data = used_data %>% filter(time < 202209),
family = poisson(link = 'log'))
starts_val <- list(
count = coef(mod),
zero = rep(0.1, length(coef(mod)))
)
mod3 <- zeroinfl(round(total) ~ offset(log(forest)) + distance + I(distance^2) + I(distance^3) + season + time_num,
data = used_data %>% filter(time < 202209),
dist = 'poisson',
link = 'log',
start = starts_val)
coef(mod)
ㅡㅐㅇ
mod
mod3 <- zeroinfl(round(total) ~ offset(log(forest)) + distance + I(distance^2) + I(distance^3) + season + time_num,
data = used_data %>% filter(time < 202209),
dist = 'nbinom',
link = 'log',
start = starts_val)
mod3 <- zeroinfl(round(total) ~ offset(log(forest)) + distance + I(distance^2) + I(distance^3) + season + time_num,
data = used_data %>% filter(time < 202209),
dist = 'negbin',
link = 'log',
start = starts_val)
summary(mod3)
starts_val <- list(
count = rep(0, length(coef(mod))),
zero = rep(0, length(coef(mod)))
)
mod3 <- zeroinfl(round(total) ~ offset(log(forest)) + distance + I(distance^2) + I(distance^3) + season + time_num,
data = used_data %>% filter(time < 202209),
dist = 'negbin',
link = 'log',
start = starts_val)
mod3 <- zeroinfl(round(total) ~ offset(log(forest)) + distance + I(distance^2) + I(distance^3) + season + time_num,
data = used_data %>% filter(time < 202209))
summary(mod3)
mod3$model
mod3$dist
summary(mod3)
ebp_baselines3 <- used_data %>%
filter(time >= 202209 & time <= 202212) %>%
mutate(mu = predict(mod3, newdata = ., type = 'response')) %>%
scanstatistics::df_to_matrix(time_col = 'SIG_CD',
location_col = 'time',
value_col = 'mu') %>% t()
zf_result <- scan_eb_zip(counts = counts,
zones = zones,
baselines = ebp_baselines3,
n_mcsim = 5000)
zf_cluster.1 <- top_clusters(zf_result, zones, k = 10, overlapping = FALSE)
zf_cluster.1
zf_result <- scan_eb_zip(counts = counts,
zones = zones,
baselines = ebp_baselines3,
n_mcsim = 5000,
baseline_type = 'zip')
apple_path <- "/Users/gogyeongtae/Library/CloudStorage/Dropbox/2022/2022 ASF/1차정리_202307/Data/시군구별 데이터/통합_shp/"
# Data
shp <- st_read(paste0(apple_path, 'shp통합4.shp'))
library(dplyr)
library(spdep)
library(scanstatistics)
library(ggplot2)
library(tidyr)
library(readxl)
library(sp)
library(magrittr)
library(terra)
library(sf)
apple_path <- "/Users/gogyeongtae/Library/CloudStorage/Dropbox/2022/2022 ASF/1차정리_202307/Data/시군구별 데이터/통합_shp/"
# Data
shp <- st_read(paste0(apple_path, 'shp통합4.shp'))
coord <- read_excel(paste0(apple_path, '시군구위도경도.xlsx'))
used_data <- read.csv('../Data/data_carcass.csv', header = TRUE)
used_data$time <- as.Date(used_data$time)
used_data$time <- format(used_data$time, '%Y%m')
used_data$time <- as.numeric(used_data$time)
used_data$distance <- exp(-1 * used_data$distance)
used_data <- used_data[,c('time', 'SIG_CD', 'distance',
'forest', 'season', 'x', 'y', 'total')]
used_data$total <- round(used_data$total)
used_data$distance2 <- used_data$distance^2
used_data$distance3 <- used_data$distance^3
mod = glm(round(total) ~ offset(log(forest)) + 1  + distance + distance2 + distance3 + season + time_num,
data = used_data %>% filter(time < 202209),
family = poisson(link = 'log'))
used_data$time_num <- rep( seq(1, 43, 1), 250)
mod = glm(round(total) ~ offset(log(forest)) + 1  + distance + distance2 + distance3 + season + time_num,
data = used_data %>% filter(time < 202209),
family = poisson(link = 'log'))
plot(used_data$total, predict(mod, type = 'response'), xlab = 'Observed', ylab = 'Predicted')
plot(used_data %>% filter(time < 202209) %>%
dplyr::select(total), predict(mod, type = 'response'), xlab = 'Observed', ylab = 'Predicted')
used_data %>% filter(time < 202209) %>%
dplyr::select(total)
pred <- predict(mod, newdata = used_data %>% filter(time >= 202209 & time <= 202212), type = 'response')
true <- used_data$total[used_data$time >= 202209 & used_data$time <= 202212]
plot(true, pred, pch = 17)
lines(seq(0,10,0.1), seq(0,10,0.1), lty = 2)
plot(true, pred, pch = 17, ylim = c(0, 10), xlim = c(0, 10)
plot(true, pred, pch = 17, ylim = c(0, 10), xlim = c(0, 10))
plot(true, pred, pch = 17, ylim = c(0, 10), xlim = c(0, 10))
lines(seq(0,10,0.1), seq(0,10,0.1), lty = 2)
lines(seq(0,10,0.1), seq(0,10,0.1), lty = 2, col = 'red')
lines(seq(0,10,0.1), seq(0,10,0.1), lty = 2, col = 'red', lwd = 2)
mod2 = glm(round(total) ~ offset(log(forest)) + 1  + distance + distance2 + distance3 + season + time_num,
data = used_data %>% filter(time < 202209),
family = poisson(link = 'log'))
pred2 <- predict(mod2, newdata = used_data %>% filter(time >= 202209 & time <= 202212), type = 'response')
true2 <- used_data$total[used_data$time >= 202209 & used_data$time <= 202212]
plot(true2, pred2, pch = 17, ylim = c(0, 10), xlim = c(0, 10))
lines(seq(0,10,0.1), seq(0,10,0.1), lty = 2, col = 'red', lwd = 2)
library(pscl)
mod3 = hurdle(total ~ offset(log(forest)) + 1  + distance + distance2 + distance3 + season + time_num,
data = used_data %>% filter(time < 202209),
dist = 'poisson', zero.dist = 'binomial')
pred3 <- predict(mod3, newdata = used_data %>% filter(time >= 202209 & time <= 202212), type = 'response')
true3 <- used_data$total[used_data$time >= 202209 & used_data$time <= 202212]
plot(true3, pred3, pch = 17, ylim = c(0, 10), xlim = c(0, 10))
lines(seq(0,10,0.1), seq(0,10,0.1), lty = 2, col = 'red', lwd = 2)
help(hurdle)
plot(true, pred, pch = 17, ylim = c(0, 10), xlim = c(0, 10), col = 'green')
points(true2, pred2, pch = 17, col = 'red')
points(true3, pred3, pch = 17, col = 'blue')
mod2 = glm.nb(round(total) ~ offset(log(forest)) + 1  + distance + distance2 + distance3 + season + time_num,
data = used_data %>% filter(time < 202209),
family = poisson(link = 'log'))
library(MASS)
mod2 = glm.nb(round(total) ~ offset(log(forest)) + 1  + distance + distance2 + distance3 + season + time_num,
data = used_data %>% filter(time < 202209),
family = poisson(link = 'log'))
mod2 = glm.nb(round(total) ~ offset(log(forest)) + 1  + distance + distance2 + distance3 + season + time_num,
data = used_data %>% filter(time < 202209),
family = 'log')
help(glm.nb)
mod2 = glm.nb(round(total) ~ offset(log(forest)) + 1  + distance + distance2 + distance3 + season + time_num,
data = used_data %>% filter(time < 202209))
pred2 <- predict(mod2, newdata = used_data %>% filter(time >= 202209 & time <= 202212), type = 'response')
true2 <- used_data$total[used_data$time >= 202209 & used_data$time <= 202212]
plot(true2, pred2, pch = 17, ylim = c(0, 10), xlim = c(0, 10))
lines(seq(0,10,0.1), seq(0,10,0.1), lty = 2, col = 'red', lwd = 2)
plot(true, pred, pch = 17, ylim = c(0, 10), xlim = c(0, 10), col = 'green')
points(true2, pred2, pch = 17, col = 'red')
points(true3, pred3, pch = 17, col = 'blue')
lines(seq(0,10,0.1), seq(0,10,0.1), lty = 2, col = 'black', lwd = 2)
legend('topleft', legend = c('Poisson', 'Negative Binomial', 'Hurdle'), col = c('green', 'red', 'blue'), pch = 17)
legend('topleft', legend = c('Poisson', 'Negative Binomial', 'ZIP'), col = c('green', 'red', 'blue'), pch = 17)
legend('topright', legend = c('Poisson', 'Negative Binomial', 'ZIP'), col = c('green', 'red', 'blue'), pch = 17)
plot(true, pred, pch = 17, ylim = c(0, 10), xlim = c(0, 10), col = 'green')
points(true2, pred2, pch = 17, col = 'red')
points(true3, pred3, pch = 17, col = 'blue')
lines(seq(0,10,0.1), seq(0,10,0.1), lty = 2, col = 'black', lwd = 2)
legend('topright', legend = c('Poisson', 'Negative Binomial', 'ZIP'), col = c('green', 'red', 'blue'), pch = 17)
pred <- predict(mod, newdata = used_data %>% filter(time <= 202209 ), type = 'response')
true <- used_data$total[used_data$time >= 202209 & used_data$time <= 202212]
plot(true, pred, pch = 17, ylim = c(0, 10), xlim = c(0, 10))
pred <- predict(mod, newdata = used_data %>% filter(time <= 202209 ), type = 'response')
true <- used_data$total[used_data$time <= 202209 ]
plot(true, pred, pch = 17, ylim = c(0, 10), xlim = c(0, 10))
lines(seq(0,10,0.1), seq(0,10,0.1), lty = 2, col = 'red', lwd = 2)
library(MASS)
mod2 = glm.nb(round(total) ~ offset(log(forest)) + 1  + distance + distance2 + distance3 + season + time_num,
data = used_data %>% filter(time < 202209))
pred2 <- predict(mod2, newdata = used_data %>% filter(time <= 202209), type = 'response')
true2 <- used_data$total[used_data$time <= 202209 ]
plot(true2, pred2, pch = 17, ylim = c(0, 10), xlim = c(0, 10))
lines(seq(0,10,0.1), seq(0,10,0.1), lty = 2, col = 'red', lwd = 2)
library(pscl)
mod3 = hurdle(total ~ offset(log(forest)) + 1  + distance + distance2 + distance3 + season + time_num,
data = used_data %>% filter(time < 202209),
dist = 'poisson', zero.dist = 'binomial')
pred3 <- predict(mod3, newdata = used_data %>% filter(time <= 202209), type = 'response')
true3 <- used_data$total[used_data$time <= 202209]
plot(true3, pred3, pch = 17, ylim = c(0, 10), xlim = c(0, 10))
lines(seq(0,10,0.1), seq(0,10,0.1), lty = 2, col = 'red', lwd = 2)
plot(true, pred, pch = 17, ylim = c(0, 10), xlim = c(0, 10), col = 'green')
points(true2, pred2, pch = 17, col = 'red')
points(true3, pred3, pch = 17, col = 'blue')
lines(seq(0,10,0.1), seq(0,10,0.1), lty = 2, col = 'black', lwd = 2)
# Fitting residual for machine learning
residual <- used_data$total - predict(mod, newdata = used_data, type = 'response')
residual2 <- used_data$total - predict(mod2, newdata = used_data, type = 'response')
residual3 <- used_data$total - predict(mod3, newdata = used_data, type = 'response')
library(randomForest)
# Fitting residual for machine learning
residual <- used_data %>% filter(time <= 202209) - predict(mod, newdata = used_data %>% filter(time <= 202209), type = 'response')
residual2 <- used_data %>% filter(time <= 202209) - predict(mod2, newdata = used_data %>% filter(time <= 202209), type = 'response')
residual3 <- used_data %>% filter(time <= 202209) - predict(mod3, newdata = used_data %>% filter(time <= 202209), type = 'response')
rf <- randomForest(residual ~ offset(log(forest)) + 1  + distance + distance2 + distance3 + season + time_num,
data = used_data %>% filter(time <= 202209))
data$residual = residual
residual
predict(mod, newdata = used_data %>% filter(time <= 202209), type = 'response')
used_data %>% filter(time <= 202209) %>% dplyr::select(total)
- predict(mod, newdata = used_data %>% filter(time <= 202209), type = 'response')
- predict(mod, newdata = used_data %>% filter(time <= 202209), type = 'response')
residual2 <- used_data %>% filter(time <= 202209) %>% dplyr::select(total)
- predict(mod2, newdata = used_data %>% filter(time <= 202209), type = 'response')
residual3 <- used_data %>% filter(time <= 202209) %>% dplyr::select(total)
residual3 <- used_data %>% filter(time <= 202209) %>% dplyr::select(total) - predict(mod3, newdata = used_data %>% filter(time <= 202209), type = 'response')
residual2 <- used_data %>% filter(time <= 202209) %>% dplyr::select(total) - predict(mod2, newdata = used_data %>% filter(time <= 202209), type = 'response')
# Fitting residual for machine learning
residual <- used_data %>% filter(time <= 202209) %>% dplyr::select(total) - predict(mod, newdata = used_data %>% filter(time <= 202209), type = 'response')
data$residual = residual
data$residual2 = residual2
data$residual3 = residual3
data
data <- used_data %>% filter(time <= 202209)
data$residual <- residual
data$residual2 <- residual2
data$residual3 <- residual3
rf <- randomForest(residual ~ offset(log(forest)) + 1  + distance + distance2 + distance3 + season + time_num,
data = data)
data
data <- used_data %>% filter(time <= 202209)
data['residual'] <- residual
data
data['residual2'] <- residual2
data['residual3'] <- residual3
rf <- randomForest(residual ~ offset(log(forest)) + 1  + distance + distance2 + distance3 + season + time_num,
data = data)
rf2 <- randomForest(residual2 ~ offset(log(forest)) + 1  + distance + distance2 + distance3 + season + time_num,
data = data)
rf3 <- randomForest(residual3 ~ offset(log(forest)) + 1  + distance + distance2 + distance3 + season + time_num,
data = data)
pred_rf <- predict(rf, newdata = used_data %>% filter(time >= 202209 & time <= 202212))
pred_rf
true_rf <- data$total[used_data$time >= 202209 & used_data$time <= 202212] - predict(mod, newdata = used_data %>% filter(time >= 202209 & time <= 202212), type = 'response')
plot(true_rf, pred_rf, pch = 17, ylim = c(-10, 10), xlim = c(-10, 10))
lines(seq(-10,10,0.1), seq(-10,10,0.1), lty = 2, col = 'red', lwd = 2)
plot(true_rf, pred_rf, pch = 17)
lines(seq(-10,10,0.1), seq(-10,10,0.1), lty = 2, col = 'red', lwd = 2)
, ylim = c(-10, 10), xlim = c(-10, 10)
plot(true_rf, pred_rf, pch = 17, ylim = c(-10, 10), xlim = c(-10, 10))
lines(seq(-10,10,0.1), seq(-10,10,0.1), lty = 2, col = 'red', lwd = 2)
mod = glm(round(total) ~ offset(log(forest)) + 1  + distance + distance2 + distance3 + season + time_num,
data = used_data %>% filter(time < 202209),
family = poisson(link = 'log'))
pred <- predict(mod, newdata = used_data %>% filter(time >= 202209 & time <= 202212), type = 'response')
true <- used_data$total[used_data$time >= 202209 & used_data$time <= 202212]
plot(true, pred, pch = 17, ylim = c(0, 10), xlim = c(0, 10))
lines(seq(0,10,0.1), seq(0,10,0.1), lty = 2, col = 'red', lwd = 2)
library(MASS)
mod2 = glm.nb(round(total) ~ offset(log(forest)) + 1  + distance + distance2 + distance3 + season + time_num,
data = used_data %>% filter(time < 202209))
pred2 <- predict(mod2, newdata = used_data %>% filter(time >= 202209 & time <= 202212), type = 'response')
true2 <- used_data$total[used_data$time >= 202209 & used_data$time <= 202212]
plot(true2, pred2, pch = 17, ylim = c(0, 10), xlim = c(0, 10))
lines(seq(0,10,0.1), seq(0,10,0.1), lty = 2, col = 'red', lwd = 2)
library(pscl)
mod3 = hurdle(total ~ offset(log(forest)) + 1  + distance + distance2 + distance3 + season + time_num,
data = used_data %>% filter(time < 202209),
dist = 'poisson', zero.dist = 'binomial')
pred3 <- predict(mod3, newdata = used_data %>% filter(time >= 202209 & time <= 202212), type = 'response')
true3 <- used_data$total[used_data$time >= 202209 & used_data$time <= 202212]
plot(true3, pred3, pch = 17, ylim = c(0, 10), xlim = c(0, 10))
lines(seq(0,10,0.1), seq(0,10,0.1), lty = 2, col = 'red', lwd = 2)
plot(true, pred, pch = 17, ylim = c(0, 10), xlim = c(0, 10), col = 'green')
points(true2, pred2, pch = 17, col = 'red')
points(true3, pred3, pch = 17, col = 'blue')
lines(seq(0,10,0.1), seq(0,10,0.1), lty = 2, col = 'black', lwd = 2)
legend('topright', legend = c('Poisson', 'Negative Binomial', 'ZIP'), col = c('green', 'red', 'blue'), pch = 17)
plot(true, pred, pch = 17, ylim = c(0, 10), xlim = c(0, 10), col = 'green')
plot(true, pred + pred_rf, pch = 17, ylim = c(0, 10), xlim = c(0, 10), col = 'red')
plot(true, pred, pch = 17, ylim = c(0, 10), xlim = c(0, 10), col = 'green')
points(true, pred + pred_rf, pch = 17, ylim = c(0, 10), xlim = c(0, 10), col = 'red')
sum(abs(true - pred))
sum(abs(true - pred - pred_rf))
sum(abs(true - pred + pred_rf))
pred_rf
lines(seq(0,10,0.1), seq(0,10,0.1), lty = 2, col = 'black', lwd = 2)
pred_rf <- predict(rf2, newdata = used_data %>% filter(time >= 202209 & time <= 202212))
true_rf <- data$total[used_data$time >= 202209 & used_data$time <= 202212] - predict(mod, newdata = used_data %>% filter(time >= 202209 & time <= 202212), type = 'response')
plot(true_rf, pred_rf, pch = 17, ylim = c(-10, 10), xlim = c(-10, 10))
lines(seq(-10,10,0.1), seq(-10,10,0.1), lty = 2, col = 'red', lwd = 2)
plot(true, pred, pch = 17, ylim = c(0, 10), xlim = c(0, 10), col = 'green')
points(true, pred + pred_rf, pch = 17, ylim = c(0, 10), xlim = c(0, 10), col = 'red')
lines(seq(0,10,0.1), seq(0,10,0.1), lty = 2, col = 'black', lwd = 2)
rf3 <- randomForest(residual3 ~ offset(log(forest)) + 1  + distance + distance2 + distance3 + season + time_num,
data = data)
pred_rf <- predict(rf3, newdata = used_data %>% filter(time >= 202209 & time <= 202212))
true_rf <- data$total[used_data$time >= 202209 & used_data$time <= 202212] - predict(mod, newdata = used_data %>% filter(time >= 202209 & time <= 202212), type = 'response')
plot(true_rf, pred_rf, pch = 17, ylim = c(-10, 10), xlim = c(-10, 10))
lines(seq(-10,10,0.1), seq(-10,10,0.1), lty = 2, col = 'red', lwd = 2)
plot(true, pred, pch = 17, ylim = c(0, 10), xlim = c(0, 10), col = 'green')
points(true, pred + pred_rf, pch = 17, ylim = c(0, 10), xlim = c(0, 10), col = 'red')
lines(seq(0,10,0.1), seq(0,10,0.1), lty = 2, col = 'black', lwd = 2)
pred_rf <- predict(rf2, newdata = used_data %>% filter(time >= 202209 & time <= 202212))
true_rf <- data$total[used_data$time >= 202209 & used_data$time <= 202212] - predict(mod, newdata = used_data %>% filter(time >= 202209 & time <= 202212), type = 'response')
plot(true_rf, pred_rf, pch = 17, ylim = c(-10, 10), xlim = c(-10, 10))
lines(seq(-10,10,0.1), seq(-10,10,0.1), lty = 2, col = 'red', lwd = 2)
plot(true, pred, pch = 17, ylim = c(0, 10), xlim = c(0, 10), col = 'green')
points(true, pred + pred_rf, pch = 17, ylim = c(0, 10), xlim = c(0, 10), col = 'red')
lines(seq(0,10,0.1), seq(0,10,0.1), lty = 2, col = 'black', lwd = 2)
sum(abs(true - pred))
sum(abs(true - pred + pred_rf))
sum(abs(true - pred - pred_rf))
true
